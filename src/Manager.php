<?php
namespace UmutPHP\WPVulnerabilityCheck;

class Manager
{
    const WPSCAN_API_URL = 'https://wpscan.com/api/v3/';

    /** @var Settings */
    private $settings;

    /** @var string */
    private $lastApiError;

    /**
     * @param Settings $settings
     */
    public function __construct(Settings $settings = null) {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }
    }

    /**
     * Main check function
     *
     * @param Settings|null $settings
     * @param Output|null $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    public function check(Settings $settings = null, Output $output = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        if ($output === null) {
            $writer = null;

            if ($this->settings->output === 'HTML') {
                $writer = new Writer\HTML();
            }

            if ($this->settings->colors === true) {
                $output = new OutputColored($writer);
            } else {
                $output = new Output($writer);
            }
        }

        $returnW = $this->checkWordPress($this->settings, $output);
        $returnP = $this->checkPlugins($this->settings, $output);
        $returnT = $this->checkThemes($this->settings, $output);

        if (!empty($this->lastApiError)) {
            $output->writeNewLine();
            $output->writeLine('ERROR: ' . $this->lastApiError);
        }

        return $returnW && $returnP && $returnT && empty($this->lastApiError);
    }

   /**
    * Check if the directory exists
    *
    * @param string $directory
    *
    * @throws Exception\NotExistsPath
    */
    private function checkDirectory($directory, Output $output = null)
    {
        if (!is_dir($directory)) {
            if ($output != null) {
                $output->writeNewLine();
                $output->writeLine("Invalid folder ($directory) is given.");
                $output->writeNewLine();
            }

            throw new \Exception("Invalid folder ($directory) is given.");
        }
    }

    /**
     * Private WordPress installation check function
     *
     * @param Settings $settings
     * @param Output $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    private function checkWordPress(Settings $settings, Output $output)
    {
        $this->checkDirectory($this->settings->path, $output);

        $version_file = realpath($this->settings->path) . DIRECTORY_SEPARATOR . "wp-includes" . DIRECTORY_SEPARATOR . "version.php";

        if (!file_exists($version_file)) {
            $output->writeNewLine();
            $output->writeLine("Invalid installation folder ($version_file) is given.");
            $output->writeNewLine();
            throw new \Exception("Invalid installation folder ($version_file) is given.");
        }

        $wp_version = $this->getWpVersion($version_file);

        if (false === $wp_version) {
            $output->writeNewLine();
            $output->writeLine("No valid WordPress version is found.");
            $output->writeNewLine();
            throw new \Exception("No valid WordPress version is found.");
        }

        $output->writeLine(
            "Checking WordPress version ..."
        );
        $output->writeNewLine();

        try {
            $vulResult = $this->checkWordPressVersion($wp_version, $settings);
            var_dump($vulResult);
            // Get Vulnerabilities and check the WordPress with version
            if (count($vulResult[$wp_version]['vulnerabilities'])) {
                $output->error(); // For vulnerability
            } else {
                $output->ok(); // For success
            }
        } catch (\Exception $e) {
            $code = $e->getCode();
            if ($code == 404) {
                // No vulnerability in database
                $output->ok();
            } else {
                $output->fail();
                $this->handleApiError($code);
            }
        }

        if (count($vulResult[$wp_version]['vulnerabilities'])) {
            if ($this->settings->output != 'NO') {
                $this->output($vulResult, $output);
            }

            return false;
        }

        return true;
    }

    /**
     * Private theme check function
     *
     * @param Settings $settings
     * @param Output $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    private function checkThemes(Settings $settings, Output $output)
    {
        $this->checkDirectory($this->settings->themes, $output);

        $files  = scandir($this->settings->themes);
        $themes = array();

        foreach ($files as $key => $value) {
            if (!$this->isComponent($value)) {
                continue;
            }

            if (is_dir($this->settings->themes . DIRECTORY_SEPARATOR . $value)) {
                if (file_exists($this->settings->themes . DIRECTORY_SEPARATOR . $value . DIRECTORY_SEPARATOR . "style.css")) {
                    $themes[$value] = $value . DIRECTORY_SEPARATOR . "style.css";
                }
            }
        }

        /** @var Result[] $results */
        $results          = array();
        $startTime        = microtime(true);
        $checkedThemes    = 0;
        $vulnerableThemes = 0;
        $totalThemeCount  = count($themes);
        $missingThemes    = array();

        $output->setTotalPluginCount($totalThemeCount);
        $output->writeNewLine();
        $output->writeLine(
            "Checking " . ($totalThemeCount === 1 ? 'theme' : 'themes') . "..."
        );
        $output->writeNewLine();
        foreach ($themes as $theme => $file) {
            try {
                $checkedThemes++;
                $vulResult = $this->checkTheme($theme, $file, $this->settings);

                // Get Vulnerabilities and check the plugin with version
                if (count($vulResult[$theme]['vulnerabilities'])) {
                    $vulnerableThemes++;
                    $output->error(); // For vulnerability
                } else {
                    $output->ok(); // For success
                    continue;
                }

                $results      = array_merge($results, $vulResult);
            } catch (\Exception $e) {
                $code = $e->getCode();
                if ($code == 404) {
                    // No vulnerability in database or custom theme
                    $output->ok();
                    $missingThemes[$theme] = array("message" => $e->getMessage());
                } else {
                    $output->fail();
                    $this->handleApiError($code);
                }
            }
        }

        $runTime = round(microtime(true) - $startTime, 1);

        $output->writeNewLine(2);

        $message = "Checked $checkedThemes " . ($checkedThemes === 1 ? 'theme' : 'themes') . " in $runTime second, ";
        if ($vulnerableThemes === 0) {
            $message .= "no vulnerability found.";
        } else {
            $message .= "found some vulnerability(s) in $vulnerableThemes ";
            $message .= ($vulnerableThemes === 1 ? 'theme.' : 'themes.');
        }

        $output->writeLine($message);

        if (!empty($missingThemes)) {
            $message = "The " . (count($missingThemes) === 1 ? 'theme which is not ' : 'themes which are not ');
            $message .= "in WPScan Vulnerability Database; " . implode(", ", array_keys($missingThemes)). ".";
            $output->writeNewLine();
            $output->writeLine($message);
            $output->writeLine("PS: You can exclude your custom themes with --exclude parameter.");
        }

        if (!empty($results)) {
            if ($this->settings->output != 'NO') {
                $this->output($results, $output);
            }

            return false;
        }

        return true;
    }

    /**
     * Private plugin check function
     *
     * @param Settings $settings
     * @param Output $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    private function checkPlugins(Settings $settings, Output $output)
    {
        $this->checkDirectory($this->settings->plugins, $output);

        $plugins = array_merge(
            $this->getPlugins($this->settings->plugins),
            $this->getMuPlugins($this->settings->MUPlugins)
        );

        /** @var Result[] $results */
        $results           = array();
        $startTime         = microtime(true);
        $checkedPlugins    = 0;
        $vulnerablePlugins = 0;
        $totalPluginCount  = count($plugins);
        $missingPlugins    = array();

        $output->setTotalPluginCount($totalPluginCount);
        $output->writeNewLine();
        $output->writeLine(
            "Checking " . ($totalPluginCount === 1 ? 'plugin' : 'plugins') . "..."
        );
        $output->writeNewLine();
        foreach ($plugins as $plugin => $meta) {
            try {
                if (in_array($plugin, $this->settings->excluded)) {
                    continue;
                }

                $checkedPlugins++;
                $vulResult = $this->checkPlugin($plugin, $meta, $this->settings);

                // Get Vulnerabilities and check the plugin with version
                if (count($vulResult[$plugin]['vulnerabilities'])) {
                    $vulnerablePlugins++;
                    $output->error(); // For vulnerability
                } else {
                    $output->ok(); // For success
                    continue;
                }

                $results      = array_merge($results, $vulResult);
            } catch (\Exception $e) {
                $code = $e->getCode();
                if ($code == 404) {
                    // No vulnerability in database or custom plugin
                    $output->ok();
                    $missingPlugins[$plugin] = array("message" => $e->getMessage());
                } else {
                    $output->fail();
                    $this->handleApiError($code);
                }
            }
        }

        $runTime = round(microtime(true) - $startTime, 1);

        $output->writeNewLine(2);

        $message = "Checked $checkedPlugins plugins in $runTime second, ";
        if ($vulnerablePlugins === 0) {
            $message .= "no vulnerability found.";
        } else {
            $message .= "found some vulnerability(s) in $vulnerablePlugins ";
            $message .= ($vulnerablePlugins === 1 ? 'plugin.' : 'plugins.');
        }

        $output->writeLine($message);

        if (!empty($missingPlugins)) {
            $message = "The " . (count($missingPlugins) === 1 ? 'plugin which is not ' : 'plugins which are not ');
            $message .= "in WPScan Vulnerability Database; " . implode(", ", array_keys($missingPlugins)). ".";
            $output->writeNewLine();
            $output->writeLine($message);
            $output->writeLine("PS: You can exclude your custom plugins with --exclude parameter.");
        }

        if (!empty($results)) {
            if ($this->settings->output != 'NO') {
                $this->output($results, $output);
            }

            return false;
        }

        return true;
    }

    /**
     * Return true if the filename is most probably a plugin
     *
     * @param string $plugin File name
     * @return boolean
     */
    public function isComponent($plugin) {
        if ($plugin === '.' || $plugin === '..' || $plugin === 'index.php') {
            return false;
        }

        if (is_array($this->settings->excluded)) {
            if (in_array($plugin, $this->settings->excluded)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Check the vulnerabities array and remove the fixed bugs
     *
     * @param array $result Result array for the plugin
     * @param string $version Version the plugin to be checked
     * @return array
     */
    public function checkVulnerabilityWithVersion($result, $version)
    {
        foreach ($result['vulnerabilities'] as $key => $value) {
            if ($value['fixed_in'] && version_compare($version, $value['fixed_in'], '>=')) {
                unset($result['vulnerabilities'][$key]);
            }
        }

        return $result;
    }

    /**
     * Check WordPress with version via API
     *
     * @param string $version
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkWordPressVersion($version, Settings $settings = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        $versionSlug = str_replace('.', '', $version);

        $vulnerabilities = $this->get($versionSlug, $this->settings->token, 'wordpresses');

        if (!isset($vulnerabilities[$version])) {
            throw new \Exception($vulnerabilities["status"], $vulnerabilities["_code"]);
        }

        return $vulnerabilities;
    }

    /**
     * Check theme with theme name via API
     *
     * @param string $themeName
     * @param string $themeFile
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkTheme($themeName, $themeFile, Settings $settings = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        $meta = $this->getThemeMetaData(
            $this->settings->themes . DIRECTORY_SEPARATOR . $themeFile
        );

        $vulnerabilities = $this->get($themeName, $this->settings->token, 'themes');

        if (!isset($vulnerabilities[$themeName])) {
            throw new \Exception($vulnerabilities["status"], $vulnerabilities["_code"]);
        }

        $vulnerabilities[$themeName] = $this->checkVulnerabilityWithVersion($vulnerabilities[$themeName], $meta['Version']);

        return $vulnerabilities;
    }

    /**
     * Check plugin with plugin name via API
     *
     * @param string $pluginName
     * @param array $meta
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkPlugin($pluginName, $meta, Settings $settings = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        $vulnerabilities = $this->get($pluginName, $this->settings->token);

        if (!isset($vulnerabilities[$pluginName])) {
            throw new \Exception($vulnerabilities["status"], $vulnerabilities["_code"]);
        }

        $vulnerabilities[$pluginName] = $this->checkVulnerabilityWithVersion($vulnerabilities[$pluginName], $meta['Version']);

        return $vulnerabilities;
    }

    /**
     * Get theme meta data from the header comment block
     *
     * @param string $file File path of the plugin file
     * @return array The array of the meta values
     */
    private function getThemeMetaData($file)
    {
        $all_headers = array(
           'Name'        => 'Theme Name',
           'ThemeURI'    => 'Theme URI',
           'Version'     => 'Version',
           'Description' => 'Description',
           'Author'      => 'Author',
           'AuthorURI'   => 'Author URI',
           'TextDomain'  => 'Text Domain',
           'DomainPath'  => 'Domain Path',
           'Network'     => 'Network',
           // Site Wide Only is deprecated in favor of Network.
           '_sitewide'   => 'Site Wide Only'
         );

        return $this->getFileMetaData($all_headers, $file);
    }

    /**
     * Get plugin meta data from the header comment block
     *
     * @param string $file File path of the plugin file
     * @return array The array of the meta values
     */
    private function getPluginMetaData($file)
    {
        $all_headers = array(
           'Name'        => 'Plugin Name',
           'PluginURI'   => 'Plugin URI',
           'Version'     => 'Version',
           'Description' => 'Description',
           'Author'      => 'Author',
           'AuthorURI'   => 'Author URI',
           'TextDomain'  => 'Text Domain',
           'DomainPath'  => 'Domain Path',
           'Network'     => 'Network',
           // Site Wide Only is deprecated in favor of Network.
           '_sitewide'   => 'Site Wide Only'
         );

        return $this->getFileMetaData($all_headers, $file);
    }

    /**
     * Get file meta data from the header comment block
     *
     * @param string $file File path of the plugin file
     * @return array The array of the meta values
     */
    private function getFileMetaData($headers, $file)
    {
        // We don't need to write to the file, so just open for reading.
        $fp = fopen($file, 'r');

        // Pull only the first 8kiB of the file in.
        $file_data = fread($fp, 8192);

        // PHP will close file handle, but we are good citizens.
        fclose($fp);

        // Make sure we catch CR-only line endings.
        $file_data = str_replace("\r", "\n", $file_data);

        foreach ($headers as $field => $regex) {
            if (preg_match( '/^[ \t\/*#@]*' . preg_quote($regex, '/') . ':(.*)$/mi', $file_data, $match) && $match[1])
                $headers[$field] = trim(preg_replace("/\s*(?:\*\/|\?>).*/", '', $match[1]));
            else
                $headers[$field] = '';
        }

        return $headers;
    }

    /**
     * Private function to get the result from the API
     *
     * @param string $name
     * @param string $APIToken
     * @param string $type
     * @return array Array decoded from JSON string
     */
    private function get($name, $APIToken, $type = "plugins") {
        $ch  = curl_init();
        $url = self::WPSCAN_API_URL . $type . '/' . $name;

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

        $headers = array(
            'Authorization: Token token=' . $APIToken
        );

        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

        $response = curl_exec($ch);
        if ($response === false) {
            $errorCode = curl_errno($ch);
            curl_close($ch);

            return ['_code' => $errorCode, 'status' => 'cURL error'];
        }

        $data = json_decode($response, true);
        $data['_code'] = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        curl_close($ch);

        return $data;
    }

    /**
     * Print result list
     *
     * @param array $results
     * @param Output $output
     * @return void
     */
    private function output($results, $output) {
        if ($this->settings->output === 'READABLE') {
            $output->writeNewLine();
            $output->writeLine(str_repeat('-', 60));
            $output->writeLine("Vulnerability Details");
            $output->writeNewLine();
        }

        foreach ($results as $plugin => $vulnerabilities) {
            if (!is_array($vulnerabilities)) {
                continue;
            }
            $output->writeResult($plugin, $vulnerabilities['vulnerabilities']);
        }
    }

    /**
     * Check the plugins directory and retrieve all plugin files with plugin data.
     *
     * WordPress only supports plugin files in the base plugins directory
     * (wp-content/plugins) and in one directory above the plugins directory
     * (wp-content/plugins/my-plugin). The file it looks for has the plugin data
     * and must be found in those two locations.
     *
     * @param string $pluginRoot Absolute path to plugins folder.
     * @return array[] Array of arrays of plugin data, keyed by plugin file name. See `get_plugin_data()`.
     */
    private function getPlugins($pluginRoot)
    {
        $wpPlugins  = array();

        // Files in wp-content/plugins directory.
        $pluginsDir = @opendir($pluginRoot);
        $pluginFiles = array();

        if ($pluginsDir) {
            while (($file = readdir($pluginsDir)) !== false) {
                if ('.' === substr($file, 0, 1)) {
                    continue;
                }

                if (is_dir($pluginRoot . '/' . $file)) {
                    $pluginsSubdir = @opendir($pluginRoot . '/' . $file);

                    if ($pluginsSubdir) {
                        while (($subfile = readdir($pluginsSubdir)) !== false) {
                            if ('.' === substr($subfile, 0, 1)) {
                                continue;
                            }

                            if ('.php' === substr($subfile, -4)) {
                                $pluginFiles[] = "$file/$subfile";
                            }
                        }

                        closedir($pluginsSubdir);
                    }
                } else {
                    if ('.php' === substr($file, -4)) {
                        $pluginFiles[] = $file;
                    }
                }
            }

            closedir($pluginsDir);
        }

        if (empty($pluginFiles)) {
            return $wpPlugins;
        }

        foreach ($pluginFiles as $pluginFile) {
            if (!is_readable("$pluginRoot/$pluginFile")) {
                continue;
            }

            $pluginData = $this->getPluginMetaData("$pluginRoot/$pluginFile");

            if (empty($pluginData['Name'])) {
                continue;
            }

            $wpPlugins[$this->pluginBasename($pluginFile)] = $pluginData;
        }

        return $wpPlugins;
    }

    /**
     * Check the mu-plugins directory and retrieve all mu-plugin files with any plugin data.
     *
     * WordPress only includes mu-plugin files in the base mu-plugins directory (wp-content/mu-plugins).
     *
     * @param string $muPluginRoot Absolute path to mu-plugins folder.
     * @return array[] Array of arrays of mu-plugin data, keyed by plugin file name.
     */
    private function getMuPlugins($muPluginRoot)
    {
        $wpPlugins = array();
        $pluginFiles = array();

        if (!is_dir($muPluginRoot)) {
            return $wpPlugins;
        }

        // Files in wp-content/mu-plugins directory.
        $pluginsDir = @opendir($muPluginRoot);
        if ($pluginsDir) {
            while (($file = readdir($pluginsDir)) !== false) {
                if ('.php' === substr($file, -4)) {
                    $pluginFiles[] = $file;
                }
            }
        } else {
            return $wpPlugins;
        }

        closedir($pluginsDir);

        if (empty($pluginFiles)) {
            return $wpPlugins;
        }

        foreach ($pluginFiles as $pluginFile) {
            if (!is_readable($muPluginRoot . "/$pluginFile")) {
                continue;
            }

            $pluginData = $this->getPluginMetaData($muPluginRoot . "/$pluginFile");

            if (empty($pluginData['Name'])) {
                $pluginData['Name'] = $pluginFile;
            }

            $wpPlugins[$this->pluginBasename($pluginFile)] = $pluginData;
        }

        if (isset($wpPlugins['index']) && filesize($muPluginRoot . '/index.php') <= 30) {
            // Silence is golden.
            unset($wpPlugins['index']);
        }

        return $wpPlugins;
    }

    /**
     * Gets the basename of a plugin.
     *
     * This method extracts the name of a plugin from its filename.
     *
     * @param string $pluginFile The filename of plugin.
     * @return string The name of a plugin.
     */
    private function pluginBasename($pluginFile)
    {
        if (false === strpos($pluginFile, '/')) {
            return basename($pluginFile, '.php');
        } else {
            return dirname($pluginFile);
        }
    }

    private function handleApiError($code)
    {
        switch ($code) {
            case 401:
                $this->lastApiError = 'API Token expired.';
                break;
            case 403:
                $this->lastApiError = 'Invalid API Token.';
                break;
            case 404:
                // No the plugin/theme found, ignored.
                break;
            case 429:
                $this->lastApiError = 'Daily API usage limit hit.';
                break;
            case 500:
                $this->lastApiError = 'WPScan API error. Status: 500.';
                break;
            case 502:
                $this->lastApiError = 'WPScan API error. Status: 502.';
                break;
            case ($code < 100):
                $this->lastApiError = 'Unable to connect to the WPScan API. cURL error: ' . $code . '.';
                break;
            default:
                $this->lastApiError = 'Unknown response from the WPScan API. Status: ' . $code . '.';
                break;
        }
    }

    /**
     * Get WordPress version without evaluating version.php file which can be unsafe.
     *
     * @param string $file path to WordPress wp-includes/version.php file
     * @return false|string
     */
    private function getWpVersion($file)
    {
        $contents = file_get_contents($file);

        if (preg_match('/\$wp_version\s+=\s+\'(.+?)\';/mi', $contents, $match)) {
            return $match[1];
        }

        return false;
    }
}
